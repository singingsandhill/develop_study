---

## 1. 인증과 인가란?

### 1.1 인증(Authentication)
- **인증**은 “해당 유저가 정말 그 유저가 맞는지”를 확인하는 절차입니다.
- 로그인할 때 아이디와 비밀번호를 입력하거나, 지문·얼굴 인식, OTP 등을 통해서 “본인이 맞다”라고 증명하는 과정을 생각하시면 됩니다.

### 1.2 인가(Authorization)
- **인가**는 “해당 유저가 어떤 리소스에 접근할 권한이 있는지”를 확인하는 절차입니다.
- 예를 들어, **관리자 페이지**에 접근하려면 **관리자 권한**(Admin Role)이 필요한 경우가 있겠죠.
- 따라서, “사용자가 인증을 이미 받았는가?”와 별개로, “해당 사용자가 어떤 권한을 가졌나?”가 핵심 포인트입니다.

> **Tip.**  
> 로그인 단계는 대개 “인증”과 “인가” 과정을 순차적으로 진행합니다.  
> 로그인 성공(=인증 완료) 후, 그 사용자가 **어떤 권한**을 갖고 있는지에 따라 페이지 접근이나 기능 사용이 제한되거나 허용됩니다(=인가).

---

## 2. 웹 애플리케이션 인증의 특수성

우리는 일상에서 **로그인**이라는 행위를 통해 쉽게 인증 과정을 경험합니다. 하지만 사실 웹 환경은 **“비연결성(Connectionless)”, “무상태(Stateless)”**라는 특수한 통신 구조를 가지고 있습니다.

### 2.1 비연결성(Connectionless)

- 서버와 클라이언트가 **실제로 계속 연결**되어 있는 것이 아니라, **요청이 있을 때만 잠시 연결**이 되고, 응답이 완료되면 바로 연결을 끊습니다.
- 채팅 앱이나 온라인 게임처럼 실시간 통신이 필요한 서비스가 아니라면, 대부분의 웹은 요청/응답 시점에만 통신이 일어납니다.
- 이러한 구조를 사용하는 이유는 **서버 자원을 절약**하기 위함입니다. 모든 클라이언트와 계속 연결 상태를 유지하려면 서버 비용이 기하급수적으로 늘어나기 때문입니다.

### 2.2 무상태(Stateless)

- 서버가 클라이언트의 **이전 요청 상태**를 저장하지 않는다는 의미입니다.
- 예를 들어, 사용자가 어떤 페이지를 방금 전에 봤는지, 이전에 로그인 요청을 했었는지 등을 기본적으로 서버가 기억하지 않습니다.
- 하지만 우리는 인터넷을 사용할 때, **연결이 끊기는 느낌**보다는 “연속적으로” 웹사이트를 사용하는 것처럼 보이죠?
  - 사실 이는 **개발자들이 여러 기법**을 동원해 “연속성”이 있는 것처럼 구현하는 것이지, HTTP 자체는 무상태 프로토콜입니다.

---

## 3. 비연결성·무상태 환경에서의 인증 유지

그렇다면 질문이 생깁니다.  
“**로그인**은 분명 인증을 통해 ‘이 사용자는 ~~이다’라는 **상태**를 확인하는 것인데, 어떻게 **무상태** 환경에서 이 정보를 계속 유지할 수 있을까?”

이에 대한 일반적인 해법 중 하나가 **쿠키-세션 기반** 인증입니다.

---

## 4. 쿠키-세션(Cookie-Session) 기반 인증

![쿠키-세션 인증 흐름 예시](https://user-images.githubusercontent.com/000000/placeholder.png)  
_(이미지는 예시이며, 실제 링크는 첨부하지 않았습니다.)_

### 4.1 쿠키-세션의 개념

- **서버**는 로그인된 사용자라는 **최소한의 정보**만 **세션 저장소(Session Store)**에 저장하고,
- **클라이언트**는 서버가 발급한 세션 식별자(=session-id)를 **쿠키**에 저장하여 **매번 요청 시** 전송합니다.
- 서버는 세션 식별자를 보고 해당 사용자가 **로그인한 사용자**인지, 권한이 어떤지 등을 판단할 수 있습니다.

### 4.2 인증 흐름

1. **사용자**가 아이디와 비밀번호로 **로그인 요청**을 보냅니다.
2. **서버**는 DB에서 유저 정보를 조회해 아이디·비밀번호가 맞는지 검사합니다.
3. 인증이 **성공**하면, **세션 저장소**에 “이 유저는 로그인되었다”는 정보를 저장합니다. (유저 정보 그 자체는 저장하지 않고, **난수(세션 ID)**만 매핑할 수도 있음)
4. 서버는 **session-id**라는 난수를 **응답**으로 돌려줍니다.
5. **클라이언트**(브라우저)는 session-id를 **쿠키**로 저장합니다.
6. 이후 **모든 요청**을 할 때, 클라이언트는 쿠키에 들어 있는 session-id를 **HTTP 헤더**에 담아 보냅니다.
7. **서버**는 헤더 안의 쿠키(session-id)를 보고, 세션 저장소에서 해당 세션 ID가 유효한지 확인합니다.
8. 유효하다면 “로그인된 사용자”로 인식하고, **인가**에 따라 처리합니다.

> **Key Point**
>
> - 로그인 후에도 새 요청이 들어올 때마다 **쿠키** 정보를 통해 인증이 유지된다는 점이 핵심입니다.
> - 서버는 이전 요청의 상태를 직접 기억하는 것이 아니라, **세션 저장소**와 **session-id** 매핑을 통해 “사용자 정보를 찾는” 방식입니다.

---

## 5. 마무리

- **인증**은 사용자 신원을 확인(로그인)하는 것이고,
- **인가**는 인증된 사용자가 어떤 자원이나 기능을 사용할 수 있는지(권한)를 결정하는 것입니다.
- **HTTP**가 연결을 계속 유지하지 않는 **무상태** 프로토콜임에도 불구하고, **쿠키-세션** 방식을 통해 로그인 상태를 유지할 수 있습니다.
- 실제 프로젝트에서 쿠키-세션 방식을 적용할 때, 브라우저 쿠키 설정이나 보안(세션 고정 공격, XSS 공격 방지 등) 이슈도 함께 고려해야 합니다.

---
